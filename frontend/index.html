<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<title>Semantic and Interactive Navigation In Videos</title>
</head>
<body>

<div class="container">
    <div class="row">
        <!-- TODO add a video loading mechanism
            <div>
            <label>Video:</label>
            <input type="text" id="video_name"/>
            <input type="button" id="videoButton" value="Load"/>
        </div>-->
        <div class="col-sm"> <!-- inputs (video, crop, query) -->
            <label >Inputs:</label>
            <input type="text" id="queryInput" class="form-control"/>
            <input type="button" id="searchT" value="Text-based search" class="btn btn-sm btn-primary"/>
            <input type="button" id="searchI" value="Crop-image-based search" class="btn btn-sm btn-secondary"/>
            <input type="button" id="objDetec" value="Object detection" class="btn btn-sm btn-secondary" />
            <div class="col-sm">
                <input class="row" style="width: 100%;" type="range" id="slider" min="1" step="1" value="1">
                <canvas class="row" style="width:100%; " id="video"></canvas>
                <canvas class="row" id="crop"></canvas>
            </div>
        </div>
        <div class="col-sm"> <!-- outputs (scores, tsne reduction, detected objects) -->
            <label class="row">Outputs:</label>
            <input type="button" id="toggleObj" value="Detected objects" class="btn btn-info"/>
            <div class="row" id="objDiv">
                <canvas id="objPlot" width="500px" height="400px" ></canvas>
            </div>
            <input type="button" id="toggleScores" value="Similarity scores chart" class="btn btn-info"/>
            <div class="row" id="scoreDiv">
                <canvas id="scorePlot" width="500px" ></canvas>
            </div>  
            <input type="button" id="toggleTsne" value="Video embeddings scatter plot in reduced embedding space" class="btn btn-info"/>
            <div class="row" id="tsneDiv">
                <canvas  id="tsnePlot" width="500px" height="500px" ></canvas>
            </div>
        </div>
    </div>
</div>

<script type='text/javascript' > 
    window.current_frame = new Image();
</script>
<script>
    /*variables declaration*/
    //document components
    var slider = document.getElementById("slider");
    var video = document.getElementById("video");
    var scorePlot = document.getElementById("scorePlot");
    var verticalLine = document.getElementById("verticalLine");
   //TODO var videoLoadButton = document.getElementById("videoButton");
    var searchText = document.getElementById("searchT");
    var searchImage = document.getElementById("searchI");
    var objDetec = document.getElementById("objDetec");
    var toggleObj = document.getElementById("toggleObj");
    var toggleScores = document.getElementById("toggleScores");
    var toggleTsne = document.getElementById("toggleTsne");

    //hiding canvas and buttons at first
    document.getElementById("objDiv").style.display = "none";
    document.getElementById("scoreDiv").style.display = "none";
    document.getElementById("tsneDiv").style.display = "none";
    toggleObj.style.display = "none";
    toggleScores.style.display = "none";
    toggleTsne.style.display = "none";

    //query results slots
    var scores = null;
    var tsne_reduction = null;
    var objs = null;

    const server_url = 'http://localhost:8000';

    //video to be loaded from /videos folder, could be that of objects or depth map
    // Y6R7T.mp4 DUDE DRINKING WATER
    var video_name = "Y6R7T.mp4";

    /*methods declaration*/
    //Plot the vertical line that indicates the current frame on the curve
    var plotMarker = (currentIndex, max, offsetX, offsetY, svg) => {
        var plotWidth = svg.clientWidth;
        var plotHeight = svg.clientHeight;

        var ctx = svg.getContext("2d");
        var x = offsetX + (currentIndex / (max - 1)) * (plotWidth - 2 * offsetX);
        
        ctx.beginPath();
        ctx.moveTo(x, offsetY);
        ctx.lineTo(x, plotHeight - offsetY);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 1;
        ctx.stroke();
    };

    //Plot the score curve
    var plotCurve = (currentIndex) => {
        if (scores == null) { return; }

        //normalize scores' array
        minScore = Math.min(...scores);
        maxScore = Math.max(...scores);
        scaledScores = scores.map(score => (score - minScore) / (maxScore - minScore));

        //offset, to keep space between plot and canvas boundaries
        var offsetX = 20;
        var offsetY = 20;

        //canvas with/length
        var plotWidth = scorePlot.clientWidth;
        var plotHeight = scorePlot.clientHeight;

        //reset the drawing
        var ctx = scorePlot.getContext("2d");
        ctx.clearRect(0, 0, plotWidth, plotHeight);

        //draw x axis
        ctx.beginPath();
        ctx.moveTo(offsetX, plotHeight - offsetY);
        ctx.lineTo(plotWidth - offsetX, plotHeight - offsetY);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.stroke();

        //draw arrow at the end of the x axis
        ctx.beginPath();
        ctx.moveTo(plotWidth - offsetX, plotHeight - offsetY);
        ctx.lineTo(plotWidth - offsetX - 5, plotHeight - offsetY + 5);
        ctx.lineTo(plotWidth - offsetX - 5, plotHeight - offsetY - 5);
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();

        //draw y axis
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY);
        ctx.lineTo(offsetX, plotHeight - offsetY);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.stroke();

        //draw arrow at the end of the y axis
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY);
        ctx.lineTo(offsetX + 5, offsetY + 5);
        ctx.lineTo(offsetX - 5, offsetY + 5);
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();

        // Draw scale values on y-axis
        for (let i = 0; i < 5; i += 1) {
            const yPos = plotHeight - offsetY - (i / 5) * (plotHeight - 2 * offsetY);

            //Math.trunc(value * 100) / 100 := a precision of 0.01
            ctx.fillText(Math.trunc(i / 5 * maxScore * 100) / 100.0, offsetX / 4, yPos);
        }

        //draw the curve
        ctx.beginPath();
        ctx.moveTo(offsetX, plotHeight - scaledScores[0] * (plotHeight - 2 * offsetY));

        for (let i = 1; i < scaledScores.length; i++) {
            var x = offsetX + (i / (scaledScores.length - 1)) * (plotWidth - 2 * offsetX);
            var y = plotHeight - offsetY - scaledScores[i] * (plotHeight - 2 * offsetY);
            ctx.lineTo(x, y);
        }

        ctx.strokeStyle = "blue";
        ctx.lineWidth = 1;
        ctx.stroke();

        //update vertical line position
        plotMarker(currentIndex, scores.length, offsetX, offsetY, scorePlot);
    };

    var plotObjects = (currentIndex) => {
        if (objs == null) { return; }

        //offset, to keep space between plot and canvas boundaries
        var offsetX = 50;
        var offsetY = 20;

        //canvas with/length
        var plotWidth = objPlot.clientWidth;
        var plotHeight = objPlot.clientHeight;

        //reset the drawing
        var ctx = objPlot.getContext("2d");
        ctx.clearRect(0, 0, plotWidth, plotHeight);

        //draw x axis
        ctx.beginPath();
        ctx.moveTo(offsetX, plotHeight - offsetY);
        ctx.lineTo(plotWidth - offsetX, plotHeight - offsetY);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.stroke();

        //draw arrow at the end of the x axis
        ctx.beginPath();
        ctx.moveTo(plotWidth - offsetX, plotHeight - offsetY);
        ctx.lineTo(plotWidth - offsetX - 5, plotHeight - offsetY + 5);
        ctx.lineTo(plotWidth - offsetX - 5, plotHeight - offsetY - 5);
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();

        //draw y axis
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY);
        ctx.lineTo(offsetX, plotHeight - offsetY);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.stroke();

        //draw arrow at the end of the y axis
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY);
        ctx.lineTo(offsetX + 5, offsetY + 5);
        ctx.lineTo(offsetX - 5, offsetY + 5);
        ctx.closePath();
        ctx.fillStyle = "black";
        ctx.fill();

        // Draw class names on y-axis
        for (var i = 0; i < objs["classes"].length; ++i) {
            const yPos = plotHeight - offsetY - (i / objs["classes"].length) * (plotHeight - 2 * offsetY);
            ctx.fillText(objs["classes"][i]["label"], offsetX / 10, yPos);
        }

        //for each timestamp, draw circles on the level of the object label
        for (var k = 0; k < objs["results"].length; ++k) {
            objects = objs["results"][k];
            for (var i = 0;i < objects.length;++i) {
                //xpos reflects the timestamp
                timestamp = objects[i]["timestamp"];
                const x = offsetX + (timestamp / objs["maxTime"]) * (plotWidth - 2 * offsetX);
                
                //matching label with plot line (ypos)
                label = objects[i]["label"];
                var j = 0;
                for (;j < objs["classes"].length; ++j) {
                    if (label == objs["classes"][j]["index"]) { break; }
                } 
                const y = plotHeight - offsetY - (j / objs["classes"].length) * (plotHeight - offsetY * 2);

                //draw circle
                dotColor = (timestamp == currentIndex)? "red" : "blue";
                dotRadius = (timestamp == currentIndex)? 4 : 2;
                ctx.beginPath();
                ctx.moveTo(x - dotRadius, y - dotRadius);
                ctx.arc(x, y, dotRadius, 0, Math.PI * 2, true);
                ctx.strokeStyle = dotColor;
                ctx.fill();
                ctx.stroke();
            }
        }

        //update vertical line position
        plotMarker(currentIndex, objs["maxTime"], offsetX, offsetY, objPlot);
    };

    var plotTsneReduction = (currentIndex) => {
        if (tsne_reduction == null) { return; }

        /*get min/max to later normalize reduction values*/
        min_x = tsne_reduction[0]['x'];
        max_x = tsne_reduction[0]['x'];
        min_y = tsne_reduction[0]['y'];
        max_y = tsne_reduction[0]['y'];

        for (i = 1;i < tsne_reduction.length;++i) {
            min_x = (min_x > tsne_reduction[i]['x'])? tsne_reduction[i]['x'] : min_x;
            max_x = (max_x < tsne_reduction[i]['x'])? tsne_reduction[i]['x'] : max_x;
            min_y = (min_y > tsne_reduction[i]['y'])? tsne_reduction[i]['y'] : min_y;
            max_y = (max_y < tsne_reduction[i]['y'])? tsne_reduction[i]['y'] : max_y;
        }

        //offset, to keep space between plot and canvas boundaries
        var offsetX = 20;
        var offsetY = 20;

        //canvas with/length
        var plotWidth = tsnePlot.clientWidth;
        var plotHeight = tsnePlot.clientHeight;

        //reset the drawing
        var ctx = tsnePlot.getContext("2d");
        ctx.clearRect(0, 0, plotWidth, plotHeight);      
        
        //draw the points (square shaped for now)
        for (i = 0;i < tsne_reduction.length;++i) {
            x = offsetX + (tsne_reduction[i]['x'] - min_x) / (max_x - min_x) * (plotWidth - 2 * offsetX);
            y = plotHeight - offsetY - (tsne_reduction[i]['y'] - min_y) / (max_y - min_y) * (plotHeight - 2 * offsetY);

            dotColor = (i == currentIndex)? "red" : "blue";
            dotRadius = (i == currentIndex)? 4 : 2;
            ctx.beginPath();
            ctx.moveTo(x - dotRadius, y - dotRadius);
            ctx.arc(x, y, dotRadius, 0, Math.PI * 2, true);
            ctx.strokeStyle = dotColor;
            ctx.fill();
            ctx.stroke();
        }
    }

    // Update score curve and vertical line position
    var updateScores = (frameIndex) => {
        if (parseInt(slider.value) - 1 != frameIndex) { slider.value = frameIndex + 1; }
        // Update plot
        plotObjects(frameIndex);
        plotCurve(frameIndex);
        plotTsneReduction(frameIndex);
        //TODO update other plots or frames later (possible in here)
    };

    /*Listeners*/
    toggleObj.addEventListener("click", () => {
        var x = document.getElementById("objDiv");
        if (x.style.display === "none") {
            x.style.display = "block";
        } else {
            x.style.display = "none";
        }
    });

    toggleScores.addEventListener("click", () => {
        var x = document.getElementById("scoreDiv");
        if (x.style.display === "none") {
            x.style.display = "block";
        } else {
            x.style.display = "none";
        }
    });

    toggleTsne.addEventListener("click", () => {
        var x = document.getElementById("tsneDiv");
        if (x.style.display === "none") {
            x.style.display = "block";
        } else {
            x.style.display = "none";
        }
    });

    //update everything at call, re-draw video and re-draw all curves/plots
    slider.addEventListener("input", async () => {
        try {
            //getting frame index from slider value
            var frameIndex = parseInt(slider.value) - 1;

            //fetch current frame
            let name_processed = video_name.split(".")[0]; 
            const response = await fetch(`${server_url}/image/${name_processed}/${frameIndex}.png`);
            const blob = await response.blob();
            const imageUrl = URL.createObjectURL(blob);

            //update component
            // Set the image source to the created URL
            window.current_frame.src = imageUrl;

            // Wait for the image to load
            window.current_frame.onload = function() {
                // Access the width and height properties
                const width = window.current_frame.width;
                const height = window.current_frame.height;

                // Get the canvas element
                const canvas = document.getElementById("video");
                const ctx = canvas.getContext("2d");

                // Set canvas dimensions to match the image
                canvas.width = width;
                canvas.height = height;

                // Clear any previous content on the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the image onto the canvas
                ctx.drawImage(window.current_frame, 0, 0, width, height);
            };

            //update plots
            updateScores(frameIndex);
        }
        catch (error) {
            console.error('Error loading similarity scores:', error);
        };
    });

    /*TODO load video mechanism
    videoLoadButton.addEventListener('click', async () => {
        try {
            video_name = document.getElementById("video_name").value;
            const response = await fetch(`${server_url}/video/${video_name}`);
            const body = await response.json();
            
            slider.max = body['frames']-1;
            console.log("video loaded")

        } catch(error) {
            console.error('Error loading videos:', error);
        }
    });*/

    //Text-based search, expecting an array of scores plus a reduction array from the server
    searchText.addEventListener('click', async () => {
        try {
            //query input
            let inputValue = document.getElementById("queryInput").value;

            //request similarity scores from the server
            const response = await fetch(`${server_url}/search?query=${inputValue}`);
            const body = await response.json();

            //only keep scores and tsne reduction values
            scores = body['scores'].map(function(value,index) { return value[1]; });
            tsne_reduction = body['tsne'];
            console.log(body);

            //adjust the slider's max value
            slider.max = scores.length;
            
            //request to update the image
            var frameIndex = parseInt(slider.value) - 1;
            
            let name_processed = video_name.split(".")[0]; 
            const imgresponse = await fetch(`${server_url}/image/${name_processed}/${frameIndex}.png`);
            const blob = await imgresponse.blob();
            const imageUrl = URL.createObjectURL(blob);

            //show buttons for toggling scores/reduction
            toggleScores.style.display = "block";
            toggleTsne.style.display = "block";

            //update the curve plot
            updateScores(frameIndex);
        } catch (error) {
            console.error('Error loading similarity scores:', error);
        }
    });

    //Image-based search, needs the cropped image to be defined (hover over the 
    //video) and expecting an array of scores plus a reduction array from the server
    searchImage.addEventListener('click', async () => {
        try {
            const dataURL = canvas1.toDataURL('image/png');
            const response = await fetch(`${server_url}/upload_png/`, 
                {method: 'POST', body: JSON.stringify({ image_data: dataURL }), 
                headers: {'Content-Type': 'application/json'}});
            const body = await response.json();

            //only keep scores and tsne reduction values
            scores = body['scores'].map(function(value,index) { return value[1]; });
            tsne_reduction = body['tsne'];
            console.log(body);

            //adjust the slider's max value
            slider.max = scores.length;
            
            //request to update the image
            var frameIndex = parseInt(slider.value) - 1;
            
            let name_processed = video_name.split(".")[0]; 
            const imgresponse = await fetch(`${server_url}/image/${name_processed}/${frameIndex}.png`);
            const blob = await imgresponse.blob();
            const imageUrl = URL.createObjectURL(blob);

            //show buttons for toggling scores/reduction
            toggleScores.style.display = "block";
            toggleTsne.style.display = "block";

            //update the curve plot
            updateScores(frameIndex);
        }
        catch (error) {
            console.error('Error loading similarity scores:', error);
        }
    });
    
    objDetec.addEventListener('click', async () => {
        //when reorganizing the detection's array, it is assumed that the detections are 
        //ordrered in terms of timestamp
        try {
            const response = await fetch(`${server_url}/video/${video_name}`);
            const body = await response.json();
            results = body["result"];

            //update slider capacity
            slider.max = body["frames"]

            classes = [];
            //organizing the final array by timestamp
            objects = [];
            //objects found in a single timestamp
            object = [];

            timestamp = 0;
            for (i = 0;i < results.length;++i) {
                //keep tabs on the timestamp
                if (results[i]["timestamp"] != timestamp) {
                    objects[timestamp] = object;
                    timestamp = results[i]["timestamp"];
                    object = [];
                }

                //keep tabs on the classes pool (no repetition)
                var found = false;
                for (j = 0;j < classes.length;++j) {
                    if (results[i]["class"] == classes[j]["index"]) {
                        found = true;
                        break;
                    } 
                }
                if (!found) {
                    classes.push({"index": results[i]["class"], "label": results[i]["name"]});
                }

                //save bounding box, timestamp and class number
                object.push({
                    "min_x": results[i]["xmin"], 
                    "min_y": results[i]["ymin"], 
                    "max_x": results[i]["xmax"], 
                    "max_y": results[i]["ymax"],
                    "label": results[i]["class"],
                    "timestamp": results[i]["timestamp"]
                });
            }

            objs = {"results": objects, "classes": classes, "maxTime": body["frames"]};
            console.log(objs);

            //show button for toggling obj chart
            toggleObj.style.display = "block";

            frameIndex = parseInt(slider.value) - 1;
            updateScores(frameIndex);
        }
        catch (error) {
            console.error('Error loading similarity scores:', error);
        }
    })
</script>
<script src="crop_script.js"></script>

</body>
</html>
